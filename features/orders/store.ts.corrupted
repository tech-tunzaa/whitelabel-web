import { create } from "zustand";
import { apiClient } from "@/lib/api/client";
import {
  Order,
  OrderFilter,
  OrderListResponse,
  OrderAction,
  OrderError,
  OrderStatus,
  PaymentStatus,
  RefundStatus,
  Cart,
  CartTotals,
  OrderApiResponse,
  CartApiResponse,
  ApiResponse,
  DeliveryDetails,
  AssignDeliveryPayload,
  Delivery,
} from "./types";

interface OrderStore {
  orders: OrderListResponse | null;
  order: Order | null;
  deliveryDetails: DeliveryDetails | null;
  cart: Cart | null;
  cartTotals: CartTotals | null;
  loading: boolean;
  storeError: OrderError | null;
  activeAction: string | null;

  // State setters
  setActiveAction: (action: string | null) => void;
  setLoading: (loading: boolean) => void;
  setStoreError: (error: OrderError | null) => void;
  setOrder: (order: Order | null) => void;
  setDeliveryDetails: (details: DeliveryDetails | null) => void;
  setOrders: (orders: OrderListResponse | null) => void;
  setCart: (cart: Cart | null) => void;
  setCartTotals: (totals: CartTotals | null) => void;

  // Order API methods
  fetchOrder: (id: string, headers?: Record<string, string>) => Promise<Order>;
  fetchOrderDeliveryDetails: (
    orderId: string,
    headers?: Record<string, string>
  ) => Promise<DeliveryDetails>;
  fetchOrders: (
    filter?: OrderFilter,
    headers?: Record<string, string>
  ) => Promise<OrderListResponse>;

  deleteOrder: (orderId: string, headers?: Record<string, string>) => Promise<void>;
  updateOrderStatus: (orderId: string, status: OrderStatus, headers?: Record<string, string>) => Promise<Order>;
  updatePaymentStatus: (
    id: string,
    paymentStatus: PaymentStatus,
    headers?: Record<string, string>
  ) => Promise<Order>;
  createRefund: (
    id: string,
    data: any,
    headers?: Record<string, string>
  ) => Promise<Order>;
  assignDeliveryPartner: (
    payload: AssignDeliveryPayload,
    headers?: Record<string, string>
  ) => Promise<Order>;
}

export const useOrderStore = create<OrderStore>()((set, get) => ({
  orders: null,
  order: null,
  deliveryDetails: null,
  cart: null,
  cartTotals: null,
  loading: false,
  storeError: null,
  activeAction: null,

  // State setters
  setActiveAction: (action) => set({ activeAction: action }),
  setLoading: (loading) => set({ loading }),
  setStoreError: (error) => set({ storeError: error }),
  setOrder: (order) => set({ order }),
  setDeliveryDetails: (details) => set({ deliveryDetails: details }),
  setOrders: (orders) => set({ orders }),
  setCart: (cart) => set({ cart }),
  setCartTotals: (totals) => set({ cartTotals: totals }),

  // Order API methods
  fetchOrders: async (
    filter: OrderFilter = {},
    headers?: Record<string, string>
  ): Promise<OrderListResponse> => {
    const { setActiveAction, setLoading, setStoreError, setOrders } = get();
    try {
      setActiveAction("fetchOrders");
      setLoading(true);

      const queryParams = new URLSearchParams();
      if (filter) {
        Object.entries(filter).forEach(([key, value]) => {
          if (value !== undefined && value !== null) {
            queryParams.append(key, String(value));
          }
        });
      }

      const response = await apiClient.get<ApiResponse<OrderListResponse>>(
        `/orders/?${queryParams.toString()}`,
        {
          headers,
        }
      );

      if (response.data.success) {
        const orderList = response.data.data;
        setOrders(orderList);
        setLoading(false);
        return orderList;
      } else {
        throw new Error(response.data.message || "Failed to fetch orders");
      }
    } catch (error: unknown) {
      console.error("Error fetching orders:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Failed to fetch orders";
      const errorStatus = (error as any)?.response?.status;
      setStoreError({
        message: errorMessage,
        status: errorStatus,
      });
      setOrders(null);
      setLoading(false);
      throw error;
    } finally {
      setActiveAction(null);
    }
  },

  fetchOrder: async (id: string, headers?: Record<string, string>) => {
    const { setActiveAction, setLoading, setStoreError, setOrder } = get();
    try {
      setActiveAction("fetchOrder");
      setLoading(true);
      const response = await apiClient.get<OrderApiResponse>(
        `/orders/${id}`,
        undefined,
        headers
      );

      let orderData = null;

      if (response.data && response.data.data) {
        orderData = response.data.data as unknown as Order;
      } else if (response.data) {
        orderData = response.data as unknown as Order;
      }

      if (orderData) {
        setOrder(orderData);
        setLoading(false);
        return orderData;
      }

      throw new Error("Order data not found or in unexpected format");
    } catch (error: unknown) {
      console.error("Error fetching order:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Failed to fetch order";
      const errorStatus = (error as any)?.response?.status;
      setStoreError({
        message: errorMessage,
        status: errorStatus,
      });
      setOrder(null);
      setLoading(false);
      throw error;
    } finally {
      setActiveAction(null);
    }
  },
  
  fetchOrderDeliveryDetails: async (orderId, headers) => {
    get().setLoading(true);
    get().setStoreError(null);
    try {
      // Expect a wrapped response as per some type definitions, but handle a direct response
      // as per observed API behavior to ensure robustness.
      const response = await apiClient.get<ApiResponse<DeliveryDetails>>(
        `/deliveries/order/${orderId}`,
        undefined,
        headers
      );

      const responseData = response.data as any; // Use 'any' to handle inconsistent API response
      let deliveryData: DeliveryDetails | null = null;

      // Check if it's a wrapped response (as types might suggest)
      if (responseData && typeof responseData.success === 'boolean' && responseData.data) {
        deliveryData = responseData.data;
      } 
      // Check if it's a direct response (as observed in network logs)
      else if (responseData && responseData.id) {
        deliveryData = responseData;
      }

      if (deliveryData) {
        get().setDeliveryDetails(deliveryData);
        return deliveryData;
      } else {
        throw new Error("Invalid or empty data format for delivery details");
      }
    } catch (error: any) {
      const errorData: OrderError = {
        message:
          error.response?.data?.message ||
          error.message ||
          "An unknown error occurred",
        details: error.response?.data?.details || {},
      };
      get().setStoreError(errorData);
      throw errorData;
    } finally {
      get().setLoading(false);
    }
  },

  deleteOrder: async (orderId: string) => {
    const { setActiveAction, setLoading, setStoreError, orders, setOrders } =
      get();
    try {
      setActiveAction("delete");
      setLoading(true);
      await apiClient.delete(`/orders/${orderId}`);

      // Remove the order from the store
      if (orders) {
        const updatedItems = orders.items.filter(
          (order) => order._id !== orderId
        );
        setOrders({
          ...orders,
          items: updatedItems,
          total: orders.total > 0 ? orders.total - 1 : 0,
        });
      }
      setLoading(false);
    } catch (error: unknown) {
      console.error("Error deleting order:", error);
      const errorMessage =
        error instanceof Error ? error.message : "Failed to delete order";
      const errorStatus = (error as any)?.response?.status;
      setStoreError({
        message: errorMessage,
        status: errorStatus,
      });
      setLoading(false);
      throw error;
    } finally {
      setActiveAction(null);
    }
  },

  updateOrderStatus: async (orderId: string, status: OrderStatus, headers?: Record<string, string>): Promise<Order> => {
    const { setActiveAction, setLoading, setStoreError, orders, setOrders, setOrder, order } = get();
    try {
      setActiveAction("updateStatus");
      setLoading(true);
      
      // Clear any previous errors
      setStoreError(null);
      
      const response = await apiClient.put<OrderApiResponse>(
        `/orders/${orderId}/status`,
        { status },
        headers
      );

      let updatedOrder: Order | null = null;
      
      // Consistent data extraction pattern
      if (response.data) {
        if ("data" in response.data && response.data.data) {
          const responseData = response.data.data;
          if (!Array.isArray(responseData)) {
            updatedOrder = responseData as unknown as Order;
          }
        } else {
          // Direct response format
          updatedOrder = response.data as unknown as Order;
        }
      }

      if (!updatedOrder) {
        throw new Error("Failed to get updated order data");
      }

      // Update the order in the store if it's the currently selected order
      if (order && order._id === orderId) {
        setOrder(updatedOrder);
      }
      
      // Update the order in the orders list if it exists
      if (orders && orders.items.length > 0) {
        const updatedOrders = orders.items.map((o) => 
          o._id === orderId ? updatedOrder : o
        );
        setOrders({ ...orders, items: updatedOrders });
      }
      
      setLoading(false);
      return updatedOrder;
    } catch (error: unknown) {
      console.error("Error updating order status:", error);
      
      // Check if it's actually a successful response with parsing error
      if ((error as any)?.response?.status === 200) {
        // If the API returned 200 but we failed to parse, don't show an error
        setLoading(false);
        // Since we can't parse the response but know the update succeeded,
        // construct a minimal response with the updated status
        if (order && order._id === orderId) {
          const minimalUpdatedOrder = { ...order, status };
          setOrder(minimalUpdatedOrder);
          return minimalUpdatedOrder;
        }
        // We need to throw here if we don't have the current order
        throw new Error("Received status 200 but couldn't parse response");
      }
      
      const errorMessage =
        error instanceof Error
          ? error.message
          : "Failed to update order status";
      const errorStatus = (error as any)?.response?.status;
      setStoreError({
        message: errorMessage,
        status: errorStatus,
      });
      setLoading(false);
      throw error;
    } finally {
      setActiveAction(null);
    }
  },

  updatePaymentStatus: async (
    id: string,
    paymentStatus: PaymentStatus,
    headers?: Record<string, string>
  ): Promise<Order> => {
    const {
      setActiveAction,
      setLoading,
      setStoreError,
      setOrder,
      orders,
      setOrders,
      order
    } = get();
    try {
      setActiveAction("updatePaymentStatus");
      setLoading(true);
      
      // Clear any previous errors
      setStoreError(null);
      
      const response = await apiClient.put<OrderApiResponse>(
        `/orders/${id}/payment`,
        { payment_status: paymentStatus },
        headers
      );

      let orderData: Order | null = null;
      
      // Consistent data extraction pattern
      if (response.data) {
        if ("data" in response.data && response.data.data) {
          const responseData = response.data.data;
          if (!Array.isArray(responseData)) {
            orderData = responseData as unknown as Order;
          }
        } else {
          // Direct response format
          orderData = response.data as unknown as Order;
        }
      }

      if (!orderData) {
        throw new Error("Order data not found or in unexpected format");
      }

      // Update the order in the store
      setOrder(orderData);

      // Update the order in the orders list if it exists
      if (orders.length > 0) {
        const updatedOrders = orders.map((o) => (o._id === id ? orderData : o));
        setOrders(updatedOrders);
      }

      setLoading(false);
      return orderData;
    } catch (error: unknown) {
      console.error("Error updating payment status:", error);
      
      // Check if it's actually a successful response with parsing error
      if ((error as any)?.response?.status === 200) {
        // If the API returned 200 but we failed to parse, don't show an error
        setLoading(false);
        // Since we can't parse the response but know the update succeeded,
        // construct a minimal response with the updated payment status
        if (order && order._id === id) {
          const minimalUpdatedOrder = { ...order, payment_status: paymentStatus };
          setOrder(minimalUpdatedOrder);
          return minimalUpdatedOrder;
        }
        // We need to throw here if we don't have the current order
        throw new Error("Received status 200 but couldn't parse response");
      }
      
      const errorMessage =
        error instanceof Error
          ? error.message
          : "Failed to update payment status";
      const errorStatus = (error as any)?.response?.status;
      setStoreError({
        message: errorMessage,
        status: errorStatus,
      });
      setLoading(false);
      throw error;
    } finally {
      setActiveAction(null);
    }
  },

  createRefund: async (
    id: string,
    data: any,
    headers?: Record<string, string>
  ): Promise<Order> => {
    const { setActiveAction, setLoading, setStoreError, setOrder, order, orders, setOrders } = get();
    try {
      setActiveAction("refund");
      setLoading(true);
      
      // Clear any previous errors
      setStoreError(null);
      
      const response = await apiClient.post<OrderApiResponse>(
        `/orders/${id}/refunds`,
        data,
        headers
      );

      let updatedOrder: Order | null = null;

      // Consistent data extraction pattern
      if (response.data) {
        if ("data" in response.data && response.data.data) {
          const responseData = response.data.data;
          if (!Array.isArray(responseData)) {
            updatedOrder = responseData as unknown as Order;
          }
        } else {
          // Direct response format
          updatedOrder = response.data as unknown as Order;
        }
      }

      if (!updatedOrder) {
        throw new Error("Updated order data not found or in unexpected format");
      }

      // Update the order in the store
      setOrder(updatedOrder);
      
      // Update the order in the orders list if it exists
      if (orders.length > 0) {
        const updatedOrders = orders.map((o) => (o._id === id ? updatedOrder : o));
        setOrders(updatedOrders);
      }
      
      setLoading(false);
      return updatedOrder;
    } catch (error: unknown) {
      console.error("Error creating refund:", error);
      
      // Check if it's actually a successful response with parsing error
      if ((error as any)?.response?.status === 200) {
        // If the API returned 200 but we failed to parse, don't show an error
        setLoading(false);
        // Since we can't parse the response but know the refund succeeded,
        // construct a minimal response with the updated status
        if (order && order._id === id) {
          // Update the current order with a new refund entry
          const newRefund = {
            refund_id: new Date().getTime().toString(),
            amount: data.amount || 0,
            reason: data.reason || "Refund processed",
            status: "approved" as RefundStatus,
            items: [],
            issued_by: data.issued_by || "",
            created_at: new Date().toISOString()
          };
          
          const currentRefunds = order.refunds || [];
          const minimalUpdatedOrder = {
            ...order,
            status: order.status === "completed" ? "refunded" as OrderStatus : order.status,
            payment_status: "refunded" as PaymentStatus,
            refunds: [...currentRefunds, newRefund]
          };
          
          setOrder(minimalUpdatedOrder);
          return minimalUpdatedOrder;
        }
        // We need to throw here if we don't have the current order
        throw new Error("Received status 200 but couldn't parse response");
      }
      
      const errorMessage =
        error instanceof Error ? error.message : "Failed to create refund";
      const errorStatus = (error as any)?.response?.status;
      setStoreError({
        message: errorMessage,
        status: errorStatus,
      });
      setLoading(false);
      throw error;
    } finally {
      setActiveAction(null);
    }
  },

  assignDeliveryPartner: async (
    payload: AssignDeliveryPayload,
    headers?: Record<string, string>
  ): Promise<Order> => {
    const { setActiveAction, setLoading, setStoreError, fetchOrder } = get();

    // We manage the loading and action state for the entire operation here
    setActiveAction("assignDeliveryPartner");
    setLoading(true);

    try {
      // Step 1: Make the API call to assign the partner
      await apiClient.post<any>(`/deliveries/`, payload, headers);

      // Step 2: On success, refetch the entire order to ensure UI has the latest data
      const updatedOrder = await fetchOrder(payload.order_id, headers);

      // fetchOrder sets loading to false on completion.
      return updatedOrder;
    } catch (error: unknown) {
      console.error("Error assigning delivery partner:", error);
      const errorMessage =
        error instanceof Error
          ? error.message
          : "Failed to assign delivery partner";
      const errorStatus = (error as any)?.response?.status;
      setStoreError({
        message: errorMessage,
        status: errorStatus,
      });

      setLoading(false); // Explicitly set loading to false on error
      throw error; // Propagate error to the UI to show a toast
    } finally {
      // Ensure the action is cleared regardless of outcome.
      setActiveAction(null);
    }
  },
}));
